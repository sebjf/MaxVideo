package maxvideo;

import types.FragmentInput;
import types.uRGB;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.managers.custom.ManagerClock;
import com.maxeler.maxeleros.managercompiler.libs.VideoWordDataType;

import displaystandards.DisplayStandard;

public abstract class MaxVideoKernel extends Kernel {

	final public static String m_name = "MaxImageGenKernel";

	protected MaxVideoKernel(KernelParameters parameters, DisplayStandard display) {
		super(parameters);

		this.Display = display;

		flush.disabled();
		io.output("displayDataOut", GenerateDisplayWordData().pack(), dfeRawBits((new VideoWordDataType()).getTotalBits()), constant.var(true));

	}

	public ManagerClock clock;

	public DisplayStandard Display;

	protected class FragmentLocation
	{
		public final DFEVar m_frame;
		public final DFEVar m_x;
		public final DFEVar m_y;

		public FragmentLocation(DFEVar frame, DFEVar x, DFEVar y)
		{
			m_frame = frame;
			m_x = x;
			m_y = y;
		}
	}

	private DFEStruct GenerateDisplayWordData()
	{
		DFEVar enable = io.scalarInput("Enable", dfeBool());

		CounterChain pixelCounterChain = control.count.makeCounterChain(enable);
		DFEVar frame = pixelCounterChain.addCounter(Integer.MAX_VALUE, 1);
		DFEVar y = pixelCounterChain.addCounter(Display.TotalHeight, 1);
		DFEVar x = pixelCounterChain.addCounter(Display.TotalWidth, 1);

		FragmentLocation input_location = new FragmentLocation(frame, x, y);

		DFEStruct videoWordData = (new VideoWordDataType()).newInstance(this);

		/*Compute the control bits first to ensure the colour calculation code cannot return a corrupted
		 *set of counters. Ideally, the members would be read only to prevent this happening.*/

		DisplayControlWord controlData = ComputePixelControlBytes(input_location);
		videoWordData["DE"] <== controlData.m_DE;
		videoWordData["HSync"] <== controlData.m_HSync;
		videoWordData["VSync"] <== controlData.m_VSync;
		videoWordData["StartOfFrame"] <== controlData.m_StartOfFrame;
		videoWordData["EndOfFrame"] <== controlData.m_EndOfFrame;

		FragmentInput input = CreateFragmentInput(input_location, controlData);

		uRGB colourData = ComputePixelColour(input);
		videoWordData["R"] <== colourData.m_R;
		videoWordData["G"] <== colourData.m_G;
		videoWordData["B"] <== colourData.m_B;

		Counter phaseCompensationFifoCounter = control.count.makeCounter(control.count.makeParams(3).withWrapMode(WrapMode.STOP_AT_MAX));

		videoWordData["phaseCompensationFifoWrEn"] <== phaseCompensationFifoCounter.getCount() > 0;
		videoWordData["phaseCompensationFifoRdEn"] <== phaseCompensationFifoCounter.getCount() > 2;

		videoWordData["Padding1"] <== constant.var(dfeRawBits(1),0);

		videoWordData["R2"] <== constant.var(dfeUInt(8),0);
		videoWordData["G2"] <== constant.var(dfeUInt(8),0);
		videoWordData["B2"] <== constant.var(dfeUInt(8),0);

		videoWordData["Metadata"] <== ComputePixelMetadata(input);

		return videoWordData;
	}

	protected class DisplayControlWord
	{
		public DFEVar m_DE;
		public DFEVar m_HSync;
		public DFEVar m_VSync;
		public DFEVar m_StartOfFrame;
		public DFEVar m_EndOfFrame;
	}

	private DisplayControlWord ComputePixelControlBytes(FragmentLocation input)
	{
		DisplayControlWord control = new DisplayControlWord();

		DFEVar h_sync_polarity = io.scalarInput("HSyncPolarity", dfeBool());
		DFEVar v_sync_polarity = io.scalarInput("VSyncPolarity", dfeBool());

		control.m_HSync	= (input.m_x < Display.H_Sync).ternaryIf(h_sync_polarity, ~h_sync_polarity);
		control.m_VSync	= (input.m_y < Display.V_Sync).ternaryIf(v_sync_polarity, ~v_sync_polarity);
		control.m_DE	= (input.m_x >= Display.H_Active_Start).and(input.m_x < Display.H_Blank_Start).and(input.m_y >= Display.V_Active_Start).and(input.m_y < Display.V_Blank_Start);

		control.m_StartOfFrame = input.m_x.eq(0).and(input.m_y.eq(0));
		control.m_EndOfFrame   = input.m_x.eq(Display.TotalWidth - 1).and(input.m_y.eq(Display.TotalHeight - 1));

		return control;
	}

	private FragmentInput CreateFragmentInput(FragmentLocation location, DisplayControlWord timing)
	{
		/* The timing specifications state that HSync & VSync should be aligned, so we need to begin our blanking periods at (0,0)
		 * and offset the active area until later in time. It is unlikely the rendering algorithm will handle negative coordinates
		 * however so this method masks these off and makes it appear to the renderer that the area is always active */

		DFEVar x = location.m_x.cast(dfeInt(32)) - Display.H_Active_Start;
		DFEVar y = location.m_y.cast(dfeInt(32)) - Display.V_Active_Start;

		FragmentInput input = new FragmentInput(location.m_frame, x, y, timing.m_DE, timing.m_StartOfFrame, timing.m_EndOfFrame);

		return input;
	}

	public DFEVar ComputePixelMetadata(FragmentInput input)
	{
		return constant.var(dfeRawBits(8), 0);
	}

	/* Override this with the image generation algorithm */

	public abstract uRGB ComputePixelColour(FragmentInput input);

}
